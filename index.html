<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>GoQuic by devsisters</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">GoQuic</h1>
      <h2 class="project-tagline">QUIC support for Go</h2>
      <a href="https://github.com/devsisters/goquic" class="btn">View on GitHub</a>
      <a href="https://registry.hub.docker.com/u/devsisters/quic-reverse-proxy/" class="btn">View on DockerHub</a>
    </section>

    <section class="main-content">
      <h1>
<a id="introducing-goquic---a-quick-way-to-use-quic" class="anchor" href="#introducing-goquic---a-quick-way-to-use-quic" aria-hidden="true"><span class="octicon octicon-link"></span></a>Introducing GoQuic - A quick way to use QUIC</h1>

<p>Mobile Internet connections are getting faster every day. We've transitioned from very slow GSM networks to 3G and then to the fastest LTE networks. Despite this increased connection speed, we constantly struggle to stably load web pages. For instance, trying to browse the Internet while moving in a subway, the experience is constantly interrupted by signal blackouts to the point that it's so unbearable we simply stop doing it. It's not a throughput problem. It's about the stability of the connection. The problem is about dealing with highly variable network environments.</p>

<p>Fortunately, we can solve this problem right now: with "QUIC". Let's see how it compares.</p>

<p><img src="images/loss2p_d200ms.gif"></p>
<h3>
<a id="difficulty-of-mobile-internet" class="anchor" href="#difficulty-of-mobile-internet" aria-hidden="true"><span class="octicon octicon-link"></span></a>Difficulty of Mobile Internet</h3>

<p>At Devsisters, the server team constantly researches ways to improve our mobile game user's online experience. More and more, mobile games are becoming increasingly sophisticated. And many of the games released today require the Internet to enjoy. But unlike their PC game counterparts, mobile environments pose some unique challenges while hosting online mobile games.</p>

<p>Mobile phones are literally "mobile". So their online connectivity changes along with the mobile phone's changes in physical location. Constant transition from this wifi to that wifi, intermittent cellular data usage, occasional cellular signal blackouts--this all makes mobile Internet connections very unstable and unreliable.</p>

<p>This kind of environment poses serious user experience problems. Everybody with a smartphone would agree on how frustrating it is when their wifi signal weakens enough to transition to a cellular data network. It makes web browsing quite unbearable for a few seconds.</p>

<p>When a wifi signal is lost during a web browsing session, wifi is disconnected and transits to other available wifi or cellular data networks. And sometimes during that period, currently loading web pages may seemingly take ages to finish. In this situation, instead of just waiting, pressing the refresh button often makes the page load faster. Keen users may have observed this phenomena.</p>

<p>This kind of problem happens because of the way TCP handles packet loss. TCP views packet loss as a signal of network congestion. Under the condition of a "network blackout", it exponentially slows down sending packets to the point where no more packets are sent. When this kind of event occurs, even if the underlying network recovers, TCP connection requires more time to recover it's connectivity. So--from the user's perspective--it is more wise to simply press the refresh button in this situation instead of waiting for the loading to complete.</p>

<p><img src="images/tcp_network.png" alt="TCP Connection Recovery After Network Blackout"></p>

<p>There are only two ways to handle this problem on HTTP: waiting indefinitely or 'timeout and retry'. This kind of problem also exists on HTTP/2 which also uses TCP. In fact, it's worse on HTTP/2 since it uses connection multiplexing network blackouts to stop all logical HTTP requests, causing significant performance degradation. This kind of problem is called head-of-line blocking.</p>

<p>Head-of-line blocking is not the only problem in HTTP. Since more and more services use HTTPS, it is becoming more expensive to initialize a connection. So it directly impacts the 'timeout and retry' strategy. In the mobile environment, where cellular latency of a 3G connection is in the 200~300ms range, the <a href="http://www.semicomplete.com/blog/geekery/ssl-latency.html">3 round-trip HTTPS connection</a> handshake is just too expensive.</p>

<h3>
<a id="googles-experiment-quic" class="anchor" href="#googles-experiment-quic" aria-hidden="true"><span class="octicon octicon-link"></span></a>Google's Experiment: QUIC</h3>

<p>Fortunately, Google is trying to solve this problem by developing and researching a new protocol named QUIC. Since this problem is happening because of HTTP/TLS and TCP, we can't fix it on the TCP layer. So QUIC is directly developed upon the UDP transport layer.</p>

<p>QUIC aims to solve the head-of-line blocking issue and the TLS connection round-trip problem. A detailed project description is available in the <a href="http://www.chromium.org/quic">QUIC project page</a>.</p>

<p>Unfortunately, since QUIC is a experimental protocol, there's only one implementation of the protocol. And that implementation exists in project Chromium. Google provides toy server/client to play with. But the source code itself is not designed to be a library. It is heavily coupled to the existing Chromium sources.</p>

<h3>
<a id="birth-of-libquic-and-goquic" class="anchor" href="#birth-of-libquic-and-goquic" aria-hidden="true"><span class="octicon octicon-link"></span></a>Birth of libquic and goquic</h3>

<p>Our initial plan was to incorporate Chromium's network runtime into our game client and server. But it turned out to be horribly hard. We then tried to extract minimal amounts of source code from Chromium to barely run QUIC code. That made the birth of project <a href="https://github.com/devsisters/libquic">libquic</a>: which is a bare necessities, stand-alone source code extracted from Chromium. It can build on Mac and Linux platforms and produce libquic library.</p>

<p>Our next step was to create a Golang binding. Since our server stack is developed in Go, it was a natural choice. This led to birth of <a href="https://github.com/devsisters/goquic">goquic</a>. It tries to mimic the built-in HTTP library and also incorporates <a href="https://github.com/bradfitz/http2">bradfitz' http2 library</a> to enable HTTP/2 when QUIC is unavailable.</p>

<h3>
<a id="performance-of-goquic" class="anchor" href="#performance-of-goquic" aria-hidden="true"><span class="octicon octicon-link"></span></a>Performance of goquic</h3>

<p>Very primitive benchmark testing has been done. Testing environments below:</p>

<table>
<thead>
<tr>
<th>Items</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Optimization</td>
<td>libquic built with <code>-O3</code> parameters</td>
</tr>
<tr>
<td>CPU</td>
<td>Intel(R) Core(TM) i7-4930K CPU @ 3.40GHz</td>
</tr>
<tr>
<td>Server Code</td>
<td><a href="https://github.com/devsisters/goquic/blob/master/example/server.go">https://github.com/devsisters/goquic/blob/master/example/server.go</a></td>
</tr>
<tr>
<td>Server Parms</td>
<td><code>GOMAXPROCS=12 ./server -port 9090 -n 12</code></td>
</tr>
<tr>
<td>Client Code</td>
<td><a href="https://github.com/devsisters/quicbench/blob/master/quicbench.go">https://github.com/devsisters/quicbench/blob/master/quicbench.go</a></td>
</tr>
<tr>
<td>Client Parms</td>
<td><code>./quicbench -u="https://example.com:9090/" -c 200 -r 1000</code></td>
</tr>
</tbody>
</table>

<p>The server code is modified to create 30B, 1kB, 5kB, 10kB HTTP body payload.
Concurrency is 200 and each thread requests 1,000 requests. It is designed to
measure ideal throughput of the server. Naturally the throughput goes down when
concurrency increases.</p>

<p>Benchmark results:</p>

<table>
<thead>
<tr>
<th>Payload Size</th>
<th>Requests per Second</th>
</tr>
</thead>
<tbody>
<tr>
<td>30B Payload</td>
<td>12131.25 RPS</td>
</tr>
<tr>
<td>1kB Payload</td>
<td>11835.13 RPS</td>
</tr>
<tr>
<td>5kB Payload</td>
<td>7816.21  RPS</td>
</tr>
<tr>
<td>10kB Payload</td>
<td>5599.73 RPS</td>
</tr>
</tbody>
</table>

<p>On the 10kB case, calculating the total network throughput is <code>458Mbps</code>.</p>

<p>How many connections per second can this server process?</p>

<p><code>./quicbench -u="https://example.com:9090/" -c 200 -r 100 -qk=false</code></p>

<p>Turning off keepalive using <code>qk</code> option results in a pure, new QUIC connection
per request. The benchmark results are <code>2905.58 CPS</code>.</p>

<h3>
<a id="quic-proxy-server-docker-image" class="anchor" href="#quic-proxy-server-docker-image" aria-hidden="true"><span class="octicon octicon-link"></span></a>QUIC Proxy Server Docker Image</h3>

<p>I used to create a QUIC reverse proxy of an existing site just for fun. So to enable people to experiment with QUIC, we've released a docker image that acts as a reverse proxy for the site of your choice. It enables QUIC along with HTTP/2, so you will enjoy the full bleeding edge of web browsing.</p>

<pre><code>$ docker run \
   -d --net="host"
   -v /PATH/TO/CERT:/opt/configs/cert
   -v /PATH/TO/CERT_PRIVATE_KEY:/opt/configs/key
   --ulimit nofile=32768 devsisters/quic-reverse-proxy:releasemode
      -cert=/opt/configs/cert
      -key=/opt/configs/key
      -addr=bind_ip
      -port=443
      -n=4
      -loglevel=2
      -- http://{BACKEND_HOST:PORT}
</code></pre>

<p>After that, you may try to connect the container with your Chrome browser. We recommend that you install <a href="https://chrome.google.com/webstore/detail/http2-and-spdy-indicator/mpbpobfflnpcgagjijhmgnchggcjblin">Chrome HTTP/2 and SPDY indicator</a>. Then you can see red lightning marks <img src="images/icon-quic.png"> on the right side of the address bar when QUIC is enabled.</p>

<p>If you are using Google Chrome Stable Release (<= 51.0) as client, you should enable quic-host-whitelist command line flag to whitelist your domain. (See <a href="https://groups.google.com/a/chromium.org/forum/#!topic/proto-quic/1K79SVSLEiU"> here</a>). Most recent version of Google Chrome Canary doesn't require whitelisting, since It uses QUIC 32 (or higher) as default.</p>

<p>Have fun! :)</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/devsisters/goquic">GoQuic</a> is maintained by <a href="https://github.com/devsisters">devsisters</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
